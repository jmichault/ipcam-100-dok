

# IMP (Ingenic Media Platform) (см. Имп_system.h)

## Базовые концепты
Программирование T20 / T21 основано на следующих концепциях:
1. Периферийное устройство (= устройство)  
    Периферийное устройство выполняет функцию. Примеры:
     *  Источник кадра: завершает вывод видеоданных.
     *  Кодировщик: выполняет функцию кодирования видео или изображения.
2. Группа  
    Группа - это наименьшая единица ввода данных. Устройство может иметь несколько групп, и каждая группа может принимать только один канал ввода данных. У группы может быть несколько результатов.  
    Группа также является контейнером для определенных "функций". См. Объяснение в разделе каналов для более подробной информации.
3. Выход  
    Вывод - это наименьшая единица вывода данных для каждой группы. Группа может иметь несколько выходов, и каждый выход может создавать только один канал данных.
4. Ячейка  
    Ячейка относится к коллекции, содержащей информацию об устройстве, группе и выходе. Он представлен в структуре данных IMPCell.
Ячейка в основном используется для Bind (@ref bind). Согласно определению «Устройство», «Группа» и «Выход», «Выход» - это узел для вывода данных, а «Группа» - это узел для ввода данных.
В Bind индекс ячейки узла вывода данных находится на выходе Output, а индекс ячейки узла ввода данных находится во входной группе (, так что вход данных Cell, Output равен бессмысленное значение).
5. Канал  
    Канал обычно относится к устройству с одной функцией. Канал получает определенную функцию при создании (экземпляра).  
    Например:  
     -  Для кодировщика один канал дополняет код H264 или функцию кодирования JPEG. Конкретный тип функции кодирования (, параметр) указывается при создании канала


     -  Для IVS канал выполняет функцию определенного алгоритма, и параметры конкретного алгоритмического типа указываются при создании канала.


     -  Для OSD есть область, аналогичная Channel, область - это определенная область наложения, которая может быть изображением PIC (), закрытием COVER ()и т. Д. .


     -  Для FrameSource канал создает исходное изображение, а канал FrameSource фактически является группой


     
     Канал, как функциональная единица, обычно должен быть зарегистрирован в группе (в дополнение к FrameSource) для приема данных. После того, как канал будет зарегистрирован в группе, он получит данные, введенные группой.

    Количество каналов, которые могут быть записаны группой различных устройств, также различается.

## Модули переплета (Переплет)

Как только две группы будут соединены с помощью Bind, данные из исходной группы будут автоматически отправлены в целевую группу.  
Поскольку группа - это наименьшая единица ввода данных, а вывод - наименьшая единица вывода данных, deviceID, groupID и outputID srcCell в обоих параметрах IMP_System_Bind (IMPCell * srcCell, IMPCell * dstCell) действительны.  

Хотя dstCell действителен только для deviceID и groupID, outputID не имеет смысла в качестве ввода данных.

Пример 1: 
```
IMPCell fs_chn0 = {DEV_ID_FS, 0, 0};    // FrameSource deviceID: DEV_ID_FS groupID: 0 outputID: 0
IMPCell enc_grp0 = {DEV_ID_ENC, 0, 0}; // ENC deviceID: DEV_ID_ENC groupID : 0 outputID: 0, où le troisième paramètre de enc_grp0 n'a pas de sens. 
int ret = IMP_System_Bind (& fs_chn0, & enc_grp0);
if(ret <0>)
  printf ("Bind FrameSource Channel0 and Encoder Group0 failed \ n");

```

* создается группа, которая генерирует ссылку от FrameSource до Encoder.


* Два канала записываются в Encoder Group, поэтому Encoder Group имеет два выхода H264 и JPEG.



Пример 2:
```
// flux de données principal
IMPCell fs_chn0 = {DEV_ID_FS, 0, 0};
IMPCell osd_grp0 = {DEV_ID_OSD, 0, 0};
IMPCell enc_grp0 = {DEV_ID_ENC, 0, 0};
int ret = IMP_System_Bind(&fs_chn0, &osd_grp0);
if (ret < 0)
    printf("Bind FrameSource Channel0 and OSD Group0 failed\n");

int ret = IMP_System_Bind(&osd_grp0, &enc_grp0);
if (ret < 0)
    printf("Bind OSD Group0 and Encoder Group0 failed\n");

// flux de données lié 
IMPCell fs_chn1_output0 = {DEV_ID_FS, 1, 0};
IMPCell ivs_grp0 = {DEV_ID_IVS, 0, 0};
IMPCell osd_grp1 = {DEV_ID_OSD, 1, 0};
IMPCell enc_grp1 = {DEV_ID_ENC, 1, 0};

int ret = IMP_System_Bind(&fs_chn1_output0, &ivs_grp0);
if (ret < 0)
    printf("Bind FrameSource Channel1 and IVS Group0 failed\n");

int ret = IMP_System_Bind(&ivs_grp0, &osd_grp1);
if (ret < 0)
    printf("Bind IVS Group0 and OSD Group1 failed\n");

int ret = IMP_System_Bind(&osd_grp1, &enc_grp1);
if (ret < 0)
    printf("Bind OSD Group1 and Encoder Group1 failed\n");
```
Это типичная программа Bind: двухканальный кодовый поток.
 * FrameSource имеет два выхода: основной поток Channel0 (1280x720) и подчиненный поток Channel1 (640x360).
   *   Основной поток: FrameSource Channel0 Bind OSD Group.0, OSD Group.0 Bind Encoder Group.0. Среди них: 
       * OSD Group.0 записала две области, которые используются для отображения временной метки и информации строки соответственно
       * Encoder Group .0 записала два канала. , которые являются кодировкой H264 и кодировкой JPEG соответственно. Среди них, если размер изображения канала кодирования JPEG не соответствует входному параметру (FrameSource Channel0), то оно будет масштабировано (программным обеспечением при T10) .) достичь цели захвата с любым разрешением.
       
Примечания:
* рекомендуется, чтобы все операции связи выполнялись во время инициализации системы.
* Операции привязки и отмены привязки нельзя вызывать динамически после активации _FrameSource_ . UnBind выполняется только после деактивации _FrameSource_.

## Функции

### int IMP\_System\_Init (пустой )
Инициализация системы IMP.
возвращает 0 в случае успеха.
После этого вызова API будет инициализирована основная структура данных, но оборудование не будет инициализировано.
Внимание: эта функция должна быть вызвана для запуска перед любой другой операцией.
### int IMP_System_Выход (пустой)

После вызова этой функции вся память и IMP _handles_ будут освобождены, и оборудование будет отключено. 
Примечание: после вызова этого API, если вы хотите снова использовать IMP, вам необходимо сбросить систему IMP.

### int64_t IMP_Система_GetTimeStamp (void)

Получите системную метку времени IMP в микросекундах.  
Возврат: время в микросекундах.

### int IMP_System_RebaseTimeStamp (базы int64_t)
Установите системную временную метку IMP в микросекундах.  
Возврат: 0 в случае успеха.

### uint32_t IMP_Система_ReadReg32 (uint32_t u32Addr)

Прочтите значение 32-битного регистра.  

### пустой IMP_System_WriteReg32 (uint32_t regAddr, valeur uint32_t)
Запишите значение в 32-битный регистр.

Примечание. Внимательно вызывайте этот API и проверьте значение реестра, иначе это может вызвать системные ошибки.

### int IMP_System_GetVersion (IMPVersion * pstVersion) 

Получите номер версии системы IMP.

### const char * IMP_System_GetCPUInfo (пусто)
Получите информацию о модели процессора.  
Примечание. Возвращаемое значение представляет собой строку модели ЦП, например, для T10 существует "T10"и "T10-Lite".

### int IMP_System_Bind (IMPCell * srcCell, IMPCell * dstCell)

Связь между исходной ячейкой и местом назначения.

Примечание 1. В соответствии с концепциями «Устройство», «Группа» и «Выход» каждое устройство может иметь несколько групп, и каждая группа может иметь несколько выходов, группа используется как интерфейс ввода устройства, а выход используется как интерфейс продукта устройства. Следовательно, ссылка фактически соединяет определенный выход устройства вывода с определенной Группой устройства ввода.

Примечание 2: После успешного установления связи данные, сгенерированные srcCell (Output) , будут автоматически переданы в целевую группу ячеек ().

### int IMP_System_UnBind (IMPCell * srcCell, IMPCell * dstCell)
Разгруппируйте источники и места назначения. 

### int IMP_System_GetBindbyDest (IMPCell * dstCell, IMPCell * srcCell)

Извлекает информацию из исходной ячейки, относящуюся к месту назначения.




